```
1. JDK와 JRE의 차이점은 무엇입니까?
    - JDK는 자바 어플리케이션을 개발하기 위한 환경을 지원하며 유용한 도구들을 포함하고 있다.  JRE는 자바 실행 환경이다. 자바프로그램의 실행환경을 지원하지만 컴파일러나 디버거 등의 도구는 포함하지 않는다.

2. ==와 equals의 차이점은 무엇입니까?
    - == 연산자는 비교하고자 하는 대상의 주소값을 비교하고, equals는 대상으 내용 자체를 비교한다.
    
3. 두 객체가 동일한 hashCode를 가지면 Equals()가 참이어야 합니다, 그렇죠?
    - 그렇지 않다. 만약 두 객체가 equals()를 통해 같다면, 두 객체의 hashCode 값은 반드시 동일해야 한다.
      하지만, hashCode가 동일하다고 해서 equals가 참인것은 아니다. Equals()는 객체의 내용을 비교하므로, 동일한 hashCode 값이라도 객체 내용이 다르면 equals는 false를 반환할 수 있다.
      
4. 자바에서 final의 기능은 무엇입니까?
    - 클래스나 변수에 final을 붙이면 정의된 상태가 변하지 않는 것을 보장한다.

5. 자바에서 Math.round(-1.5)는 무엇을 의미합니까?
    - 주어진 숫자를 반올림한 결과를 반한한다. 즉 결과는 -1이다.

6. 문자열은 기본 데이터 유형입니까?
    - 문자열은 기본 데이터 유형(primitive data type)이 아니다. 문자열은 여러 문자로 구성된 데이터이며, 자바에서는 문자열을 다루기 위해 String 클래스를 제공한다.

7. Java에서 문자열을 조작하기 위한 클래스는 무엇입니까? 그들 사이의 차이점은 무엇입니까?
    - 문자열을 조작하기 위해 주로 사용되는 클래스는 StringBuilder/StringBuffer 이다. String은 변경 불가능(immutable) 클래스로 객체를 변경하면 새로운 String 객체가 생성된다.
      StringBuilder/StringBuffer는 변경 가능한 클래스로 동적인 수정이 필요할 때 사용된다. StringBuilder는 단일 스레드 환경, StringBuffer는 멀티 스레드 환경에서 사용된다.
    
8. String str="i"는 String str=new String("i")와 동의어입니까?
    - String str="i"는 리터럴 표기법으로 문자열 리터럴은 내부적으로 문자열 풀에 저장된다. 같은 문자열 리터럴를 갖는 다른 변수들은 실제로 같은 문자열 객체를 참조하게 된다. "i" 문자열 리터럴은 이미 문자열 풀에 존재하면 그것을 참조하게 된다.       
      String str=new String("i")는 새로운 String 객체를 생성하는것으로, 문자열 리터럴 "i"를 인자로 넘겨서 새로운 String 인스턴스를 생성한다. 이렇게 하면 항상 새로운 문자열 객체가 생성되며, 문자열 풀을 우회하게 된다.
      결론적으로 두 표기법은 비슷해 보이지만, 리터럴 표기법을 사용하는 것이 문자열 풀을 이용하므로 메몰 관리 및 성능 측면에서 효율적이다.
      
9. 문자열을 반전시키는 가장 좋은 방법은 무엇인가 ? 
    - 문자열을 반전시키는 가장 간단하고 좋은 방법은 StringBuilder 또는 StringBuffer 클래스의 reverse() 메서드를 사용하는 것

10. String 클래스의 일반적인 메서드는 무엇인가 ?
    - length(): 문자열의 길이를 반환한다
      charAt(index): 지정된 인덱스의 문자를 반환합니다.
      substring(beginIndex, endIndex): 지정된 인덱스 범위에 해당하는 부분 문자열을 반환한다. beginIndex는 포함되고, endIndex는 포함되지 않는다.
      equals(other): 다른 문자열과 현재 문자열을 비교하여 값이 같은지 확인합니다.
      compareTo(other): 다른 문자열과 현재 문자열을 사전식으로 비교합니다.
      toUpperCase(): 문자열을 모두 대문자로 변환한 새로운 문자열을 반환합니다.
      toLowerCase(): 문자열을 모두 소문자로 변환한 새로운 문자열을 반환합니다.
      contains(str): 지정된 문자열이 현재 문자열에 포함되어 있는지 여부를 확인합니다.
      replace(oldChar, newChar): 문자열 내의 모든 oldChar를 newChar로 대체한 새로운 문자열을 반환합니다.
      split(regex): 지정된 정규 표현식을 기준으로 문자열을 분할하여 문자열 배열로 반환합니다.
      trim(): 문자열의 앞뒤 공백을 제거한 새로운 문자열을 반환합니다.

11. 추상클래스에 추상 메서드가 있어야 하는가 ?
    - 추상 클래스에는 추상 메서드가 있을 수도 있고 없을 수도 있다. 추상 클래스는 일반 클래스와 달리 인스턴스를 직접 생성할 수 없는 클래스이며, 하나 이상의 추상 메서드를 포함할 수 있다.
      추상 메서드는 구현이 없이 선언만 되어 있는 메서드이며, 이를 상속받은 구체적인 하위 클래스에서 반드시 구현해야 한다. 추상 클래스는 추상 메서드 외에도 일반적인 메서드, 필드 생성자 등을 가질 수 있다.
      
12. 일반 클래스와 추상 클래스의 차이점은 무엇인가 ?
    - 일반 클래스는 인스턴스를 직접 생성하여 사용할 수 있으며, 모든 메서드가 구현되어 있다. 반면에 추상 클래스는 인스턴스를 직접 생성할 수 없으며 추상 메서드를 포함할 수 있다.
      추상 클래스는 하위 클래스에서 추상 메서드를 구현하도록 강제하는 역할을 하며, 일반 클래스는 그런 제약이 없다. 일반 클래스는 필요에 따라 상속되거나 확장될 수 있다.
      
13. final은 추상 클래스를 수정할 때 사용할 수 있나요?
    - final을 사용하면 클래스, 메스드 또는 변수를 수정할 수 없게 만든다. 추상클래스를 final로 선언하면 해당 클래스는 더 이상 상속될 수 없게 된다. 그러므로 더 이상 추상클래스를 확장할 수 없다.
      하지만 추상 클래스의 메서드들은 오버라이딩하여 구현할 수 있다. final 키워드는 추상 클래스 내의 메서드에 사용될 수 있지만, 추상 클래스 자체에는 사용될 수 없습니다.        
     
14. 자바 컨테이너란 무엇인가요?
    - 객체들을 저장하고 관리하는 자료구조이다. 컨테이너는 객체들을 효율적으로 저장하고 검색하고 조작하는 기능을 제공
    
15. Collection과 Collections의 차이는 무엇인가요?
    - Collection은 자바에서 제공하는 인터페이스이다. 다양한 하위 인터페이스와 클래스를 확장하여 구체적인 데이터 저장 및 관리 방법을 정의하고 있다. 예를 들어, List, Set, Queue 등이 Collection 인터페이스를 확장하여 다양한 종류의 데이터 저장 및 조작을 지원한다.
      Collections는 자바에서 제공하는 유틸리티 클래스이다. 다양한 유틸리티 메서드를 이용하여 Collection 객체들을 조작하고 관리하는데 사용된다.
      요약하자면, "Collection"은 데이터 요소들을 저장하고 관리하는 인터페이스를 나타내며, "Collections"는 이러한 Collection 객체들을 조작하고 관리하기 위한 유틸리티 클래스를 나타냅니다.

16. List, Set, Map의 차이점을 말해주세요.
    - 컬렉션 인터페이스의 세 가지 주요 구현 유형이다. List는 순서가 있는 객체들의 모음으로 중복을 허용, Set은 중복을 하용하지 않는다. Map은 키와 값의 쌍으로 이루어진 객체의 모음이다. 각 키는 고유해야 하며, 키를 통해 값을 조회하거나 수정할 수 있다.
   
17. HashMap과 Hashtable의 차이는 무엇인가요?         
    - 해쉬맵과 해쉬테이블은 둘다 map 인터페이스를 구현한 클래스이다. 두 클래스의 차이점은 다음과 같다.
      동기화: 해쉬테이블은 스레드에 안전한 동기화된 메서드를 제공하지만 해쉬맵은 동기화를 지원하지 않는다.
      null: 해쉬테이블은 널을 허용하지 않는다.
      성능: 일반적으로 해쉬맵은 해쉬테이블보다 더 높은 성능을 가지며, 동기화하가 꼭 필요하지 않는 경우에는 해쉬맵을 사용하는 것이 좋다.
      
18. 각각 어떤 상황에서 HashMap과 TreeMap을 선택하나요?
    - 정렬: 트리맵은 키의 정렬을 유지한다. 해쉬맵은 정렬되지 않은 순서로 요소를 저장한다.
      성능: 해쉬맵은 일반적으로 더 빠른검색 및 삽입속도를 제공한다. 트리맵은 정렬된 키에 대한 작업에서 더 빠른 성능을 보여준다.
      메모리 사용: 트리맵은 정렬을 위해 추가적인 메모리를 사용한다. 해쉬맵은 정렬에 필요한 추가 메모리를 사용하지 않는다.
      
19. HashMap 구현 원칙은 무엇인가요?
    - 해시 테이블을 기반으로 한 자료구조로, 키-값 쌍을 저장하고 검색하는데 사용된다. 구현원칙은 다음과 같다.
      해쉬 함수를 사용하여 키를 해시 코드로 변환한다.
      해시 충돌이 발생할 경우 충돌을 해결하기 위해 체이닝 기법을 사용한다.
      내부적으로 배열과 버킷으로 구성되며, 배열은 해시 코드를 인덱스로 사용하여 버킷에 접근한다.
      동적 크기 조정 기능을 제공하여 성능과 메모리 사용을 최적화 한다.
      키 객체는  hashCode()와 equals() 메서드를 구현해야 한다.
      HashMap은 Collections Framework에 포함되어 있으며, O(1)의 평균 시간 복잡도를 가지는 효율적인 자료 구조입니다. 적절한 사용과 설정이 중요하다.

20. HashSet 구현 원칙은 무엇인가요?
    - Set 인터페이스를 구현한 클래스로, 중복된 값을 허용하지 않는 집합을 나타낸다. HashSet은 해시 테이블을 사용하여 요소를 저장하며, 고유한 값만을 저장하고 순서를 보장하지 않는다.

21. ArrayList와 LinkedList의 차이점은 무엇인가요?
    - 내부구조: ArrayList는 배열을 사용하여 요소를 저장하고 인덱스로 직접 접근할 수 있다. LinkedList는 노드의 연결리스트로 요소를 저장하며, 인덱스 접근은 선형 탑색을 필요로 한다.
      삽입과 삭제: ArrayList는 요소의 삽입과 삭제가 느리지만, 인덱스 기반으로 작업할 때는 빠른 접근 속도를 가진다. LinkedList는 요소 삽입과 삭제가 빠르지만 인덱스 접근이 느리다.
      메모리 사용: ArrayList는 각 요소를 위한 고정된 크기의 배열을 사용하므로 메모리 사용이 상대적으로 작다. LinkedList는 각 요소에 대해 추가 메모리를 사용하여 노드를 유지해야 하므로 메모리 사용이 더 크다.
                        
22. Array에서 List로 전환하려면 어떻게 해야하나요?
    - 배열을 리스트로 바꾸기 위해 Arrays.asList() 메서드를 사용할 수 있다
      리스트를 배열로 바꾸기 위해 List.toArray() 메서드를 사용할 수 있다.
      
23.  ArrayList와 Vector의 차이점을 말해주세요.
    - 둘다 List 인터페이스를 구현한 클래이다. 차이점은 다음과 같다.
      동기화: vector는 스레드에 안전한 동기화된 메서드를 제공하지만 ArrayList는 동기화를 지원하지 않는다.
      성능: 일반적으로 ArrayList는 더 빠른 성능을 제공한다. vector는 동기화 관련 오버헤드로 인해 더 느릴 수 있다.
      크기조정: ArrayList는 요소가 추가될 때 자동으로 크기를 조정합니다. Vector는 요소가 추가될 때 크기를 조정하기 위해 추가적인 오버헤드가 발생할 수 있습니다.

24. Array와 ArrayList의 차이점을 말해주세요.
    - 크기의 가변성: Array는 고정된 크기를 가지며, 생성할 때 크기를 지정하고 그 크기 이상의 요소를 추가할 수 없다. 반면에 ArrayList는 크기를 동적으로 조정할 수 있으며, 요소를 추가하거나 제거함에 따라 크기가 자동 조절된다
      타입의 유연성: Array는 특정한 데이터 타입만 저장할 수 있다. 예를 들어 정수형 배열은 정수 값만 저장할 수 있다. ArrayList는 제네릭을 사용하여 다양한 데이터 타입의 요소를 저장할 수 있다.
      메서드와 기능: Array는 간단한 인덱스 기반의 접근방식을 사용하여 요소에 접근하고 수정할 수 있다. ArrayList는 배열과 비슷한 인덱스 기반 접근 방식을 제공하면서도 추가적인 메서드와 기능을 가지고 있다.
                 예를 들어, ArrayList는 요소를 추가하거나 제거하는 메서드, 검색 및 정렬 기능 등을 제공한다.
      메모리 할당: Array는 크기가 고정되어 있고 인덱스 기반의 접근 방식을 사용하기 때문에 요소에 대한 접근 및 수정이 빠르다. 반면에 ArrayList은 크기가 동적으로 조정되므로 배열의 크기를 조정하는 추가 작업이 필요하며 약간의 성능 오버헤드가 발생할 수 있다.    
                그러나 대부분의 상황에서는 성능 차이가 미미하며, 유연성과 편의성 측면에서 ArrayList를 더 많이 사용한다.
                
25. Queue에서, poll()과 remove()의 차이는 무엇인가요?
    - poll(): Queue에서 가장 앞에 있는 요소를 제거하고 반환한다. 대기열이 비어있을 경우에는 null을 반환한다.
      remove(): Queue에서 가장 앞에 있는 요소를 제거하고 반환한다. 대기열이 비어있을 경우에는 NoSuchElementException예외가 발생한다.
      
26. thread-safe한 컬렉션 클래스들은 무엇이 있을까요?
    - java.util.concurrent 패키지에서 제공되는 클래스들이 스레드로부터 안전한 컬렉션 클래스입니다. 몇 가지 예시로는 ConcurrentHashMap, ConcurrentLinkedQueue, CopyOnWriteArrayList 등이 있습니다.       

27. iterator란 무엇인가요?
    - iterator란 컬렉션의 요소들에 대해 반복하면서 순차적으로 접근하기 위한 인터페이스이다. iterator란 컬렉션 내의 요소들을 읽을 수 있으며, 요소를 삭제할 수도 있다.

28. iterator의 사용 목적은 무엇인가요? 어떤 특징이 있죠?
    - iterator의 목적은 컬렉션 내의 요소들을 순회하면서 접근하기 위함이다. 반복자를 사용하면 컬렉션의 내부 구조에 상관없이 요소들을 일관된 방식으로 접근할 수 있다. 반복자는 컬렉션에 대한 안전한 순회를 제공하고, 요소를 추가, 수정, 삭제하지 않으면서 요소들에 대한 연속적인 접근을 가능하게 한다.
    
29. iterator와 listIterator의 차이는 무엇인가요?
    - iterator는 컬렉션의 요소들을 단방향으로만 반복할 수 있다. ListIterator는 iterator의 기능을 포함하면서 양방향으로 반복하고 요소를 수정할 수 있는 기능도 제공한다.
      ListIterator는 List 인터페이스를 구현한 컬렉션 클래스에서만 사용할 수 있습니다. Iterator는 모든 컬렉션 클래스에서 사용할 수 있습니다.         

30. 병렬성과 동시성의 차이점은 무엇인가 ?
    - 병렬성은 여러 작업을 동시에 실행하여 전체 작업을 가속화 하는것을 의미한다. 각 작업은 별도의 실행 단위인 스레드 또는 프로세스에 할당된다.
    - 동시성은 여러 작업이 동시에 실행되는 것처럼 보이도록 스케쥴링 되는 것을 의미한다. 작업은 시분할 방식으로 실행되며, 각 작업은 일부 시간 동안 실행된다.

31. 스레드와 프로세스의 차이를 말해주세요.
    - 스레드는 프로세스 내에서 실행되는 실행 단위이다. 한 프로세스는 여러 개의 스레드를 가질 수 있으며, 스레드는 공유 자원에 접근할 수 있다.
      프로세스는 운영 체제에서 실행 중인 프로그램 인스턴스를 나타낸다. 각 프로세스는 독립된 메모리 공간과 자원을 가지며, 다른 프로세스와는 분리되어 실행된다.
      
32. 데몬 스레드는 무엇인가 ? 
    - 데몬 스레드는 백그라운드에서 실행되는 스레드로, 다른 일반 스레드가 종료되면 자동으로 종료된다. 주로 보조적인 작업을 수행하며, 예를 들어 가비지 컬렉션 등을 처리하는데 사용된다.      






























```