```
1. JDK와 JRE의 차이점은 무엇입니까?
    - JDK는 자바 어플리케이션을 개발하기 위한 환경을 지원하며 유용한 도구들을 포함하고 있다.  JRE는 자바 실행 환경이다. 자바프로그램의 실행환경을 지원하지만 컴파일러나 디버거 등의 도구는 포함하지 않는다.

2. ==와 equals의 차이점은 무엇입니까?
    - == 연산자는 비교하고자 하는 대상의 주소값을 비교하고, equals는 대상으 내용 자체를 비교한다.
    
3. 두 객체가 동일한 hashCode를 가지면 Equals()가 참이어야 합니다, 그렇죠?
    - 그렇지 않다. 만약 두 객체가 equals()를 통해 같다면, 두 객체의 hashCode 값은 반드시 동일해야 한다.
      하지만, hashCode가 동일하다고 해서 equals가 참인것은 아니다. Equals()는 객체의 내용을 비교하므로, 동일한 hashCode 값이라도 객체 내용이 다르면 equals는 false를 반환할 수 있다.
      
4. 자바에서 final의 기능은 무엇입니까?
    - 클래스나 변수에 final을 붙이면 정의된 상태가 변하지 않는 것을 보장한다.

5. 자바에서 Math.round(-1.5)는 무엇을 의미합니까?
    - 주어진 숫자를 반올림한 결과를 반한한다. 즉 결과는 -1이다.

6. 문자열은 기본 데이터 유형입니까?
    - 문자열은 기본 데이터 유형(primitive data type)이 아니다. 문자열은 여러 문자로 구성된 데이터이며, 자바에서는 문자열을 다루기 위해 String 클래스를 제공한다.

7. Java에서 문자열을 조작하기 위한 클래스는 무엇입니까? 그들 사이의 차이점은 무엇입니까?
    - 문자열을 조작하기 위해 주로 사용되는 클래스는 StringBuilder/StringBuffer 이다. String은 변경 불가능(immutable) 클래스로 객체를 변경하면 새로운 String 객체가 생성된다.
      StringBuilder/StringBuffer는 변경 가능한 클래스로 동적인 수정이 필요할 때 사용된다. StringBuilder는 단일 스레드 환경, StringBuffer는 멀티 스레드 환경에서 사용된다.
    
8. String str="i"는 String str=new String("i")와 동의어입니까?
    - String str="i"는 리터럴 표기법으로 문자열 리터럴은 내부적으로 문자열 풀에 저장된다. 같은 문자열 리터럴를 갖는 다른 변수들은 실제로 같은 문자열 객체를 참조하게 된다. "i" 문자열 리터럴은 이미 문자열 풀에 존재하면 그것을 참조하게 된다.       
      String str=new String("i")는 새로운 String 객체를 생성하는것으로, 문자열 리터럴 "i"를 인자로 넘겨서 새로운 String 인스턴스를 생성한다. 이렇게 하면 항상 새로운 문자열 객체가 생성되며, 문자열 풀을 우회하게 된다.
      결론적으로 두 표기법은 비슷해 보이지만, 리터럴 표기법을 사용하는 것이 문자열 풀을 이용하므로 메몰 관리 및 성능 측면에서 효율적이다.
      
9. 문자열을 반전시키는 가장 좋은 방법은 무엇인가 ? 
    - 문자열을 반전시키는 가장 간단하고 좋은 방법은 StringBuilder 또는 StringBuffer 클래스의 reverse() 메서드를 사용하는 것

10. String 클래스의 일반적인 메서드는 무엇인가 ?
    - length(): 문자열의 길이를 반환한다
      charAt(index): 지정된 인덱스의 문자를 반환합니다.
      substring(beginIndex, endIndex): 지정된 인덱스 범위에 해당하는 부분 문자열을 반환한다. beginIndex는 포함되고, endIndex는 포함되지 않는다.
      equals(other): 다른 문자열과 현재 문자열을 비교하여 값이 같은지 확인합니다.
      compareTo(other): 다른 문자열과 현재 문자열을 사전식으로 비교합니다.
      toUpperCase(): 문자열을 모두 대문자로 변환한 새로운 문자열을 반환합니다.
      toLowerCase(): 문자열을 모두 소문자로 변환한 새로운 문자열을 반환합니다.
      contains(str): 지정된 문자열이 현재 문자열에 포함되어 있는지 여부를 확인합니다.
      replace(oldChar, newChar): 문자열 내의 모든 oldChar를 newChar로 대체한 새로운 문자열을 반환합니다.
      split(regex): 지정된 정규 표현식을 기준으로 문자열을 분할하여 문자열 배열로 반환합니다.
      trim(): 문자열의 앞뒤 공백을 제거한 새로운 문자열을 반환합니다.

11. 추상클래스에 추상 메서드가 있어야 하는가 ?
    - 추상 클래스에는 추상 메서드가 있을 수도 있고 없을 수도 있다. 추상 클래스는 일반 클래스와 달리 인스턴스를 직접 생성할 수 없는 클래스이며, 하나 이상의 추상 메서드를 포함할 수 있다.
      추상 메서드는 구현이 없이 선언만 되어 있는 메서드이며, 이를 상속받은 구체적인 하위 클래스에서 반드시 구현해야 한다. 추상 클래스는 추상 메서드 외에도 일반적인 메서드, 필드 생성자 등을 가질 수 있다.
      
12. 일반 클래스와 추상 클래스의 차이점은 무엇인가 ?
    - 일반 클래스는 인스턴스를 직접 생성하여 사용할 수 있으며, 모든 메서드가 구현되어 있다. 반면에 추상 클래스는 인스턴스를 직접 생성할 수 없으며 추상 메서드를 포함할 수 있다.
      추상 클래스는 하위 클래스에서 추상 메서드를 구현하도록 강제하는 역할을 하며, 일반 클래스는 그런 제약이 없다. 일반 클래스는 필요에 따라 상속되거나 확장될 수 있다.
      
13. final은 추상 클래스를 수정할 때 사용할 수 있나요?
    - final을 사용하면 클래스, 메스드 또는 변수를 수정할 수 없게 만든다. 추상클래스를 final로 선언하면 해당 클래스는 더 이상 상속될 수 없게 된다. 그러므로 더 이상 추상클래스를 확장할 수 없다.
      하지만 추상 클래스의 메서드들은 오버라이딩하여 구현할 수 있다. final 키워드는 추상 클래스 내의 메서드에 사용될 수 있지만, 추상 클래스 자체에는 사용될 수 없습니다.        
     
14. 자바 컨테이너란 무엇인가요?
    - 객체들을 저장하고 관리하는 자료구조이다. 컨테이너는 객체들을 효율적으로 저장하고 검색하고 조작하는 기능을 제공
    
15. Collection과 Collections의 차이는 무엇인가요?
    - Collection은 자바에서 제공하는 인터페이스이다. 다양한 하위 인터페이스와 클래스를 확장하여 구체적인 데이터 저장 및 관리 방법을 정의하고 있다. 예를 들어, List, Set, Queue 등이 Collection 인터페이스를 확장하여 다양한 종류의 데이터 저장 및 조작을 지원한다.
      Collections는 자바에서 제공하는 유틸리티 클래스이다. 다양한 유틸리티 메서드를 이용하여 Collection 객체들을 조작하고 관리하는데 사용된다.
      요약하자면, "Collection"은 데이터 요소들을 저장하고 관리하는 인터페이스를 나타내며, "Collections"는 이러한 Collection 객체들을 조작하고 관리하기 위한 유틸리티 클래스를 나타냅니다.

16. List, Set, Map의 차이점을 말해주세요.
    - 컬렉션 인터페이스의 세 가지 주요 구현 유형이다. List는 순서가 있는 객체들의 모음으로 중복을 허용, Set은 중복을 하용하지 않는다. Map은 키와 값의 쌍으로 이루어진 객체의 모음이다. 각 키는 고유해야 하며, 키를 통해 값을 조회하거나 수정할 수 있다.
   
17. HashMap과 Hashtable의 차이는 무엇인가요?         
    - 해쉬맵과 해쉬테이블은 둘다 map 인터페이스를 구현한 클래스이다. 두 클래스의 차이점은 다음과 같다.
      동기화: 해쉬테이블은 스레드에 안전한 동기화된 메서드를 제공하지만 해쉬맵은 동기화를 지원하지 않는다.
      null: 해쉬테이블은 널을 허용하지 않는다.
      성능: 일반적으로 해쉬맵은 해쉬테이블보다 더 높은 성능을 가지며, 동기화하가 꼭 필요하지 않는 경우에는 해쉬맵을 사용하는 것이 좋다.
      
18. 각각 어떤 상황에서 HashMap과 TreeMap을 선택하나요?
    - 정렬: 트리맵은 키의 정렬을 유지한다. 해쉬맵은 정렬되지 않은 순서로 요소를 저장한다.
      성능: 해쉬맵은 일반적으로 더 빠른검색 및 삽입속도를 제공한다. 트리맵은 정렬된 키에 대한 작업에서 더 빠른 성능을 보여준다.
      메모리 사용: 트리맵은 정렬을 위해 추가적인 메모리를 사용한다. 해쉬맵은 정렬에 필요한 추가 메모리를 사용하지 않는다.
      
19. HashMap 구현 원칙은 무엇인가요?
    - 해시 테이블을 기반으로 한 자료구조로, 키-값 쌍을 저장하고 검색하는데 사용된다. 구현원칙은 다음과 같다.
      해쉬 함수를 사용하여 키를 해시 코드로 변환한다.
      해시 충돌이 발생할 경우 충돌을 해결하기 위해 체이닝 기법을 사용한다.
      내부적으로 배열과 버킷으로 구성되며, 배열은 해시 코드를 인덱스로 사용하여 버킷에 접근한다.
      동적 크기 조정 기능을 제공하여 성능과 메모리 사용을 최적화 한다.
      키 객체는  hashCode()와 equals() 메서드를 구현해야 한다.
      HashMap은 Collections Framework에 포함되어 있으며, O(1)의 평균 시간 복잡도를 가지는 효율적인 자료 구조입니다. 적절한 사용과 설정이 중요하다.

20. HashSet 구현 원칙은 무엇인가요?
    - Set 인터페이스를 구현한 클래스로, 중복된 값을 허용하지 않는 집합을 나타낸다. HashSet은 해시 테이블을 사용하여 요소를 저장하며, 고유한 값만을 저장하고 순서를 보장하지 않는다.

21. ArrayList와 LinkedList의 차이점은 무엇인가요?
    - 내부구조: ArrayList는 배열을 사용하여 요소를 저장하고 인덱스로 직접 접근할 수 있다. LinkedList는 노드의 연결리스트로 요소를 저장하며, 인덱스 접근은 선형 탑색을 필요로 한다.
      삽입과 삭제: ArrayList는 요소의 삽입과 삭제가 느리지만, 인덱스 기반으로 작업할 때는 빠른 접근 속도를 가진다. LinkedList는 요소 삽입과 삭제가 빠르지만 인덱스 접근이 느리다.
      메모리 사용: ArrayList는 각 요소를 위한 고정된 크기의 배열을 사용하므로 메모리 사용이 상대적으로 작다. LinkedList는 각 요소에 대해 추가 메모리를 사용하여 노드를 유지해야 하므로 메모리 사용이 더 크다.
                        
22. Array에서 List로 전환하려면 어떻게 해야하나요?
    - 배열을 리스트로 바꾸기 위해 Arrays.asList() 메서드를 사용할 수 있다
      리스트를 배열로 바꾸기 위해 List.toArray() 메서드를 사용할 수 있다.
      
23.  ArrayList와 Vector의 차이점을 말해주세요.
    - 둘다 List 인터페이스를 구현한 클래이다. 차이점은 다음과 같다.
      동기화: vector는 스레드에 안전한 동기화된 메서드를 제공하지만 ArrayList는 동기화를 지원하지 않는다.
      성능: 일반적으로 ArrayList는 더 빠른 성능을 제공한다. vector는 동기화 관련 오버헤드로 인해 더 느릴 수 있다.
      크기조정: ArrayList는 요소가 추가될 때 자동으로 크기를 조정합니다. Vector는 요소가 추가될 때 크기를 조정하기 위해 추가적인 오버헤드가 발생할 수 있습니다.

24. Array와 ArrayList의 차이점을 말해주세요.
    - 크기의 가변성: Array는 고정된 크기를 가지며, 생성할 때 크기를 지정하고 그 크기 이상의 요소를 추가할 수 없다. 반면에 ArrayList는 크기를 동적으로 조정할 수 있으며, 요소를 추가하거나 제거함에 따라 크기가 자동 조절된다
      타입의 유연성: Array는 특정한 데이터 타입만 저장할 수 있다. 예를 들어 정수형 배열은 정수 값만 저장할 수 있다. ArrayList는 제네릭을 사용하여 다양한 데이터 타입의 요소를 저장할 수 있다.
      메서드와 기능: Array는 간단한 인덱스 기반의 접근방식을 사용하여 요소에 접근하고 수정할 수 있다. ArrayList는 배열과 비슷한 인덱스 기반 접근 방식을 제공하면서도 추가적인 메서드와 기능을 가지고 있다.
                 예를 들어, ArrayList는 요소를 추가하거나 제거하는 메서드, 검색 및 정렬 기능 등을 제공한다.
      메모리 할당: Array는 크기가 고정되어 있고 인덱스 기반의 접근 방식을 사용하기 때문에 요소에 대한 접근 및 수정이 빠르다. 반면에 ArrayList은 크기가 동적으로 조정되므로 배열의 크기를 조정하는 추가 작업이 필요하며 약간의 성능 오버헤드가 발생할 수 있다.    
                그러나 대부분의 상황에서는 성능 차이가 미미하며, 유연성과 편의성 측면에서 ArrayList를 더 많이 사용한다.
                
25. Queue에서, poll()과 remove()의 차이는 무엇인가요?
    - poll(): Queue에서 가장 앞에 있는 요소를 제거하고 반환한다. 대기열이 비어있을 경우에는 null을 반환한다.
      remove(): Queue에서 가장 앞에 있는 요소를 제거하고 반환한다. 대기열이 비어있을 경우에는 NoSuchElementException예외가 발생한다.
      
26. thread-safe한 컬렉션 클래스들은 무엇이 있을까요?
    - java.util.concurrent 패키지에서 제공되는 클래스들이 스레드로부터 안전한 컬렉션 클래스입니다. 몇 가지 예시로는 ConcurrentHashMap, ConcurrentLinkedQueue, CopyOnWriteArrayList 등이 있습니다.       

27. iterator란 무엇인가요?
    - iterator란 컬렉션의 요소들에 대해 반복하면서 순차적으로 접근하기 위한 인터페이스이다. iterator란 컬렉션 내의 요소들을 읽을 수 있으며, 요소를 삭제할 수도 있다.

28. iterator의 사용 목적은 무엇인가요? 어떤 특징이 있죠?
    - iterator의 목적은 컬렉션 내의 요소들을 순회하면서 접근하기 위함이다. 반복자를 사용하면 컬렉션의 내부 구조에 상관없이 요소들을 일관된 방식으로 접근할 수 있다. 반복자는 컬렉션에 대한 안전한 순회를 제공하고, 요소를 추가, 수정, 삭제하지 않으면서 요소들에 대한 연속적인 접근을 가능하게 한다.
    
29. iterator와 listIterator의 차이는 무엇인가요?
    - iterator는 컬렉션의 요소들을 단방향으로만 반복할 수 있다. ListIterator는 iterator의 기능을 포함하면서 양방향으로 반복하고 요소를 수정할 수 있는 기능도 제공한다.
      ListIterator는 List 인터페이스를 구현한 컬렉션 클래스에서만 사용할 수 있습니다. Iterator는 모든 컬렉션 클래스에서 사용할 수 있습니다.         

30. 병렬성과 동시성의 차이점은 무엇인가 ?
    - 병렬성은 여러 작업을 동시에 실행하여 전체 작업을 가속화 하는것을 의미한다. 각 작업은 별도의 실행 단위인 스레드 또는 프로세스에 할당된다.
    - 동시성은 여러 작업이 동시에 실행되는 것처럼 보이도록 스케쥴링 되는 것을 의미한다. 작업은 시분할 방식으로 실행되며, 각 작업은 일부 시간 동안 실행된다.

31. 스레드와 프로세스의 차이를 말해주세요.
    - 스레드는 프로세스 내에서 실행되는 실행 단위이다. 한 프로세스는 여러 개의 스레드를 가질 수 있으며, 스레드는 공유 자원에 접근할 수 있다.
      프로세스는 운영 체제에서 실행 중인 프로그램 인스턴스를 나타낸다. 각 프로세스는 독립된 메모리 공간과 자원을 가지며, 다른 프로세스와는 분리되어 실행된다.
      
32. 데몬 스레드는 무엇인가 ? 
    - 데몬 스레드는 백그라운드에서 실행되는 스레드로, 다른 일반 스레드가 종료되면 자동으로 종료된다. 주로 보조적인 작업을 수행하며, 예를 들어 가비지 컬렉션 등을 처리하는데 사용된다.     

33. 스레드를 만드는 방법을 나열해 주세요.
    - (1) Thread 클래스를 상속받아 새로운 클래스를 작성하고, run() 메서드를 오버라이딩하여 동작을 정의한다.
      (2) Runnalbe 인터페이스를 구현하는 클래스를 작성하고, 이를 Thread 클래스의 생성자에 전달하여 스레드를 생성합니다.
      
34. runnable과 callable의 차이는 무엇인가요?
    - runnable은 스레드에서 실행할 수 있는 작업 단위를 나타내는 인터페이스이다. runnable 인터페이스를 구현한 객체는 run() 메서드를 구현해야 한다. run() 메서드는 스레드가 수행할 작업을 정의하고 해당 작업은 별도의 스레드에서 동시에 실행 될 수 있다.
      스레드를 생성하고 runnable 객체를 전달하여 스레드가 해당 객체의 run() 메서드를 실행하도록 할 수 있다.
       
      callable은 메서드를 실행할 수 있는 개념을 나타낸다. callable은 별도의 스레드에서 실행되는 것이 아니라, 현제 실행 흐름에서 동기적으로 호출되는 것을 의미한다.  

35. 스레드의 여러가지 상태에 대해 말해주세요.
    - New: 스레드가 생성되었지만 아직 시작되지 않은 상태입니다.
      Runnable: 스레드가 실행 가능한 상태로, 실행을 위해 대기하고 있습니다.
      Running: 스레드가 실행 중인 상태입니다.
      Blocked: 스레드가 블록되어 다른 스레드에 의해 사용 중인 공유 자원을 기다리는 상태입니다.
      Waiting: 스레드가 다른 스레드에 의해 통지될 때까지 대기하고 있는 상태입니다.
      Timed Waiting: 스레드가 주어진 시간 동안 대기하고 있는 상태입니다.
      Terminated: 스레드의 실행이 완료되었거나 종료되었음을 나타내는 상태입니다.

36. sleep()과 wait()의 차이는 무엇인가요?
    - sleep()는 스레드를 주어진 시간 동안 일시적으로 정지시키는 메서드이다. 스레드는 해당 시간이 경과하면 다시 실행 가능한 상태가 된다.
      wait()은 스레들르 일시적으로 대기 상태로 만드는 메서드이다. 다른 스레드에 의해 통지되기 전까지 대기하며, 통지받으면 다시 실행 가능한 상태가 된다.

37. notify()와 notifyAll()의 차이점은 정확히 무엇입니까?
    - notify()는 wait() 메서드에 의해 대기 중인 스레드 중 하나를 임의로 선택하여 깨우는 역할을 합니다. 
      선택된 스레드만이 실행 가능한 상태가 되고, 다른 스레드들은 여전히 대기 상태에 머무릅니다.
      notifyAll()은 wait() 메서드에 의해 대기 중인 모든 스레드를 깨웁니다. 모든 스레드들이 실행 가능한 상태가 되어 경쟁적으로 실행될 수 있습니다.                
     
38. thread run()과 tnread start()의 차이는 무엇인가요?      
    - run() 메소드는 스레드가 실행되는 실제 코드 블록을 정의한다. 스레드 객체를 생성한 후에 run() 메서드를 직접 호출하게 되면, 해당 스레드는 현재 실행중인 스레드와 동일한 스레드에서 실행된다. 따라서 멀티스레딩의 이점을 활용하지 못하게 된다
      start() 메서드는 스레드를 실제로 실행하기 위해 호출된다. start() 메서드를 호출하면 새로운 스레드가 생성되어 run() 메서드 내의 코드가 별도의 스레드에서 실행된다. 
      따라서, run() 메서드를 호출하면 스레드가 현재 스레드에서 실행되고, start() 메서드를 호출하면 스레드가 별도의 실행 흐름에서 병렬적으로 실행됩니다. 일반적으로 멀티스레딩을 활용하기 위해서는 start() 메서드를 사용해야 합니다.

39. 스레드 풀을 생성할 수 있는 여러가지 방법을 말해주세요.       
    - 스레드 풀을 생성하는 방법에는 크게 두 가지가 있다.
      ThreadPoolExecutor 클래스를 직접 사용하여 스레드 풀을 생성합니다. 이 클래스는 다양한 구성 옵션을 제공하며, 스레드 풀의 동작을 세밀하게 제어할 수 있습니다.
      Java.util.concurrent 패키지에서 제공하는 Executor 프레임워크를 사용하여 스레드 풀을 생성합니다. ExecutorService 인터페이스를 구현하는 클래스인 ThreadPoolExecutor가 내부적으로 사용됩니다.

40. 스레드 풀의 상태에 대해 말해주세요.
    - Running: 스레드 풀이 실행중인 상태이다. 스레드들이 작업을 처리하고 있는 상태이다.
      Shuting Down: 스레드 풀이 종료되기 위해 점진적으로 작업을 중지하고 있는 상태이다. 현재 실행 중인 작업은 완료되지만, 새로운 작업은 받지 않는다.
      Terminated: 스레드 풀이 완전히 종료되었으며, 더 이상 실행되지 않는 상태이다.

41. 스레드 풀에서 submit()과 execute()의 차이는 무엇인가요?
    - submit() 메서드는 Callable 또는 Runable 인터페이스를 구현한 작업을 스레드 풀에 제출한다. 작업을 제출하면 Future 객체를 반환한다. Future 객체를 통해 작업의 실행 결과나 상태를 추적하고 가져올 수 있다. 또 작업이 완료되었을 때 결과를 가져오는 메서드는 get()을 호출할 수 있다.
      execute() 메서드는 'Runnable' 인터페이스를 구현한 작업을 스레드 풀에 제출한다. execute는 작업을 제출하고 해당 작업이 완료될 때 까지 기다리지 않는다. 따라서 작업의 결과는를 가져올 수는 없다.(작업이 예외를 던지면 예외가 스레드 내에서 처리되지 않는다. 해당 스레드는 종료되고, 스레드 풀은 새로운 스레드를 생성하여 작업을 계속 처리)
      
42. 자바에서 다중 스레드 작업의 안정성을 보장하는 방법은 ?        
    - 상호배제: 공유된 자원에 대한 동시 접근을 제어하기 위해 상호 배제 메커니즘을 사용해야 한다. synchronized 키워드나 Lock 객체를 사용하여 임계 영역을 설정하고, 하나의 스레드만이 해당 영역에 접근할 수 있도록 해야 한다.
      스레드 간 통신: 스레드 간의 데이터 공유 및 동기화를 위해 적절한 통신 메커니즘을 사용해아 한다.  wait(), notify(), notifyAll() 메서드를 활용하여 스레드 간의 상호 작용을 조율할 수 있습니다.
      Thread-Safe 클래스 사용: 이러한 클래스들은 내부적으로 동기화를 처리하여 여러 스레드로부터 안전하게 사용 될 수 있도록 한다. 예를 들어, ConcurrentHashMap, AtomicInteger 등이 있습니다.
      데이터 동기화: 여러 스레드에서 공유되는 데이터에 접근할 때 동기화 메커니즘을 사용하여 데이터 일관성을 유지해야 한다. 스레드가 공유 데이터를 읽고 쓰는 동안 다른 스레드가 동시에 접근하지 못하도록 보호합니다.
      스레드 안전한 컬렉션 사용: 자바에서는 스레드 안전한 컬렉션을 제공하여 동시성 문제를 해결할 수 있도록 합니다. ConcurrentHashMap, CopyOnWriteArrayList 등이 스레드 안전한 컬렉션의 예입니다.
      
43. reflection이란 무엇인가요?       
    - reflection은 실행 중인 프로그램의 구조를 분석하고 조작하는 데 사용되는 자바의 기능이다. 런타임 시에 클래스의 메서드, 필드, 생서자 등의 정보를 가져오고, 이를 통해 객체를 동적으로 생성하거나 메서드를 호출하거나, 필드에 접근하는 등의 작업을 수행할 수 있다.
    
44. 자바 직렬화란 무엇인가요? 어떤 상황에서 필요한가요?  
     - 자바 직렬화는 객체를 바이트 스트림으로 변환하는 프로세스를 의미한다. 이렇게 직렬화된 객체는 파일이나 네트워크를 통해 전송하거나 저장할 수 있다. 직렬화를 통해 객체의 상태를 보존하고 복원할 수 있으며, 객체 그래프를 유지하면서 데이터를 전송하거나 저장하는 데 사용된다.
       직렬화는 주로 분산 시스템, 영속성(객체 저장) 등의 경우에 필요합니다.

45. 동적 프록시란 무엇이고 어디에 응용 될 수 있는가 ?
    - 동적 프록시는 런타임에 인터페이스의 구현체를 동적으로 생성하는 기술이다. 동적 프록시를 사용하면 프록시 객체를 통해 실제 객체에 대한 호출을 중간에 가로채고 처리할 수 있다.
      이를 통해 객체에 대한 추가적인 로직을 삽입하거나, 호출 전후에 작업을 수행할 수 있따.

46. 동적 프록시 사용방법                 
    - 동적 프록시를 사용하려면 java.lang.reflect 패키지의 Proxy 클래스와 InvocationHandler 인터페이스를 사용해야 합니다. 
      먼저, InvocationHandler 인터페이스를 구현한 클래스를 작성하고, invoke() 메서드를 오버라이딩하여 호출 전후에 수행할 로직을 구현합니다. 
      그런 다음 Proxy.newProxyInstance() 메서드를 사용하여 동적 프록시 객체를 생성합니다. 
      이 메서드에는 ClassLoader, 구현할 인터페이스 목록 및 InvocationHandler 인터페이스를 구현한 객체를 전달해야 합니다. 
      이렇게 생성된 동적 프록시 객체는 원하는 인터페이스를 구현하고, 호출되는 메서드에 대해 정의한 로직을 수행할 수 있습니다. 
      동적 프록시 객체를 사용하여 원본 객체에 접근하고 메서드 호출을 중간에서 가로채어 원하는 작업을 수행할 수 있습니다.
      
47. 객체 복사가 사용되는 이유는 무엇인가요?      
    - 객체 복제는 기존 객체의 동일한 복사본을 만드는 과정으로, 원본 객체의 상태를 보존하면서 독립적인 복사본을 생성할 수 있다.
        (1) 객체의 안전한 수정 및 변경 가능성을 보장하기 위해 원본 객체를 보호하려는 경우
        (2) 객체의 복사본을 다른 스레드에 전달하여 동시성 문제를 방지하려는 경우
        (3) 객체의 상태를 기반으로 새로운 객체를 생성하려는 경우 
 
48. 객체 복사가 작동하는 원리는?
    - 객체 복사 Cloneable 인터페이스를 구현하고 clone() 메서드를 오버라이딩하여 수행됩니다. 기본적으로 clone() 메서드는 얕은 복사를 수행하며, 복사된 객체의 필드는 원본 객체와 같은 메모리를 참조합니다. 객체의 필드가 기본 데이터 유형이면 값이 복사되고, 참조 유형이면 참조만 복사됩니다. 따라서 원본 객체와 복사본은 같은 객체를 참조할 수 있습니다.

49. 깊은 복사와 얕은 복사의 차이점은 무엇인가 ?
    - 얕은 복사(Shallow Copy): 얕은 복사는 객체의 필드를 복사할 때, 필드의 참조를 그대로 복사합니다. 따라서 원본 객체와 복사본은 같은 참조를 공유하게 되어, 한 객체의 상태 변경이 다른 객체에 영향을 줄 수 있습니다.
      깊은 복사(Deep Copy): 깊은 복사는 객체의 필드를 복사할 때, 필드의 새로운 인스턴스를 생성하여 복사합니다. 따라서 원본 객체와 복사본은 완전히 독립적인 객체가 되어, 한 객체의 상태 변경이 다른 객체에 영향을 주지 않습니다. 
      깊은 복사는 객체 그래프를 재귀적으로 탐색하여 모든 필드를 복사하는 것을 의미합니다.     
      
50. jsp와 서블릿의 차이는 무엇인가
    - jsp는 html에 자바 코드를 삽인하여 동적 웹 페이지를 생성하는 반면, 서블릿은 자바 클래스로 웹 요청을 처리하는 로직을 구현한다
      jsp는 웹 디자인가 표현에 더 적합하며, 서블릿은 비즈니스 로직 처리에 더 적합한다. jsp는 서블릿으로 변환되어 실행되므로, 실제로는 서블릿 기반으로 동작한다
      
51. jsp를 기본 제공하는 객체는 무엇이 있나요?           
    - request: 클라이언트의 요청 정보와 데이터를 저장하고 전달합니다.
      response: 클라이언트로 응답을 보내는 메서드와 도구를 제공합니다.
      session: 클라이언트와 서버 간의 세션 정보를 저장하고 유지합니다.
      application: 웹 애플리케이션 수준의 데이터를 저장하고 전달합니다.
      out: 출력 스트림을 제공하여 응답을 생성합니다.
      pageContext: JSP 페이지와 관련된 컨텍스트 정보에 액세스합니다.
      
52. 4개의 jsp scope에는 무엇이 있나요?
    - page: 현재 페이지 내에서만 유효한 스코프입니다.
      request: 현재 요청 내에서만 유효한 스코프입니다.
      session: 사용자 세션 내에서 유효한 스코프입니다.
      application: 웹 애플리케이션 전반에 걸쳐 유효한 스코프입니다.       
      
53. 세션과 쿠키의 차이점은 무엇인가 ?
    - 세션과 쿠키는 웹 애플리케이션에 사용되는 상태 관리 기술이다. 쿠키는 클라이언트 측에 주정되는 작은 데이터 조각이며, 클라이언트의 요청과 응답 헤더에 포함된다. 주로 클라이언트 식별과 상태관리에 사용된다. 쿠키는 클라이언트 측에서 관리되며 만료 날짜 및 시간을 설정할 수 있다.
      세션은 서버 측에 상태 정볼르 저장하는데 사용되는 객체입니다. 각 클라이언트에 대해 고유한 세션 id가 생성되며 이를 통해 클라이언트와 서버 간의 상태 정보를 유지한다. 세션은 일정 시간 동안 유지되며 서버 측에서 관리된다

54. 세션 처리 절차
    - 서버에 요청 -> 세션 id 생성 후 클라이언트에 전송 -> 클라이언트는 세션 id를 쿠키 또는 url 매개 변수로 저장 -> 이 후 요청에서 id를 서버에 제공 -> 서버는 제공받은 id를 기반으로 해당 세션을 식별하고 관련 상태를 유지하거나 업데이트
      -> 세션은 일정 시간동안 유지되며 클라이언트가 세션을 종료하거나 만료되면 삭제된다.

55. 클라이언트의 쿠키가 비활성화 된 경우 세션을 사용할 수 있는가             
    - 일반적으로 클라이언트가 쿠키를 비활성화 하면 세션을 사용할 수 없다. 세션 id는 대부분 쿠키를 통해 클라이언트에 전송되기 때문이다. 그러나 세션 ID를 URL 매개 변수로 전달하여 세션을 사용하는 대체 방법을 사용할 수 있습니다. URL 재작성 및 관련 설정을 통해 세션 관리 방법을 변경할 수도 있습니다.
    
56. Spring MVC와 Struts의 차이점은 무엇인가요?    
    - spring mvc: 어노테이션을 통한 구성이 가능하고 di와 aop를 지원한다, 유연하고 확장성이 뛰어나며, 다양한 view resolver를 지원한다
      struts: xml 기반의 설정이 가능하면 di와 aop를 지원하지 않는다. 기본적으로 jsp를 사용하며, 레이아웃 관리를 제공한다
      
57. sql 인젝션을 피하는 방법은 무엇일까 ?
    - Prepared Statement 또는 Parameterized Query를 사용하여 동적 쿼리 생성을 피합니다.
      입력 데이터의 유효성을 검증하고 필요한 경우, 데이터 필터링과 이스케이프 처리를 수행한다
      데이터베이스 계정에는 최소한의 권한만 부여하여 보안을 강화시킨다
      orm을 사용한다

58. xss 공격은 무엇이며, 어떻게 방지할 수 있는가
    - xss란 악의적인 사용자가 웹 페이지에 스크립트 코드를 삽입하여, 이를 통해 다른 사용자의 정보를 탈취하거나 악의적인 동작들을 수행하는 공격이다
      방지 방법: 입력데이터 필터링 및 이스케이프 처리, 적절한 http 헤더 설정, 취약점 검토

59. csrf 공격은 무엇이며, 어떻게 방지할 수 있는가
    - csrf 공격은 인증된 사용자의 웹 브라우저를 통해 악의적인 요청이 서버에 전송되는 공격이다. 공격자는 희생자의 세션 정보를 이용하여 특정 도작을 실행시키거나 데이터를 조작할 수 있다.
      방지 방법: csrf 토큰을 사용하여 각 요청마다 토큰을 생성하고 검증한다, SameSite 쿠키 속성을 설정하여 외부 도메인에서의 쿠키 사용을 제한합니다, HTTP Referer 검증을 수행하여 요청의 출처를 확인합니다, 웹 애플리케이션 방화벽(WAF) 등의 보안 도구를 사용하여 CSRF 공격을 탐지하고 차단합니다.
      
60. throw와 throws의 차이점은 무엇인가요
    - throw: "throw"는 프로그램 실행 중에 예외를 명시적으로 발생시키는 데 사용됩니다. 예외가 발생한 상황을 감지하고 해당 예외를 생성하여 프로그램의 특정 부분에서 처리할 수 있도록 합니다. "throw" 문을 사용하여 특정 유형의 예외를 던질 수 있습니다.
      throws: 메서든 선언부에서 사용하며 해당 메서드가 하나 이상의 예외를 발생시킬 수 있다는 것을 나타낸다.

61. final, finally, finalize 각각의 의미와 차이점은 무엇인가요?
    - final: 변수, 메서드, 클래스를 불변으로 만들어 준다
      finally: 예외처리에서 사용되며 항상 실행되는 코드 블록이다
      finalize: 객체의 가비지 컬렉션 전에 호출되는 메서드로, Java 9부터는 권장되지 않음.
      
62. try-catch-finally 구문에서 어느 부분이 생략될 수 있나요?
    - "catch" 블록은 생략할 수 있습니다. 이 경우, "try" 블록 내에서 예외가 발생하면 해당 예외는 처리되지 않고 호출 스택을 따라 상위 메서드로 전달됩니다. 즉, 어떤 예외든 해당 "try-catch" 구문에서 처리되지 않을 것입니다.

63. catch 블록이 생략된 경우 finally 블록은 실행됩니까?
    - 실행된다
    
64. 몇 가지 일반적인 예외 클래스의 예는 무엇인가요?
    - NullPointerException: 객체 참조가 null인 상태에서 메서드 또는 필드에 접근하려고 할 때 발생합니다.
      ArrayIndexOutOfBoundsException: 배열의 인덱스 범위를 초과하여 접근하려고 할 때 발생합니다.
      FileNotFoundException: 파일을 찾을 수 없거나 접근할 수 없을 때 발생합니다.
      IOException: 입출력 작업 중에 예외 상황이 발생할 때 발생합니다.
      ClassNotFoundException: 클래스를 찾을 수 없을 때 발생합니다.
      ArithmeticException: 수치 연산에서 예외적인 상황이 발생할 때 발생합니다.             

65. HTTP 응답 코드 301과 302의 의미는 무엇이며, 그 차이는 무엇인가요?
    - HTTP 301은 "영구적인 이동"을 나타내며, 리소스의 URL이 영구적으로 변경되었음을 의미합니다. 클라이언트는 새로운 URL로 리소스에 접근해야 합니다.
      HTTP 302는 "임시적인 이동"을 나타내며, 리소스의 URL이 일시적으로 변경되었음을 의미합니다. 클라이언트는 임시적인 URL로 리소스에 접근하고, 원래 URL을 계속 사용해야 합니다.
      
66. 포워드와 리다이렉트의 차이점은 무엇인가요?
    - 포워드는 서버 내에서의 요청 전달을 의미한다. 웹 컨테이너 내에서 처리되며, 클라이언트의 브라우저에는 실제 페이지 전환이 발생하지 않는다. 클레이언트는 실제 전환 내용을 인지하지 못한다
      리다이렉트: 클라이언트에게 새로운 URL로 이동하도록 알려줍니다. 클라이언트는 새로운 URL로 요청을 보내고, 서버는 해당 페이지를 반환합니다.

67. TCP와 UDP의 차이점은 무엇인가요?
    - TCP(Transmission Control Protocol)는 연결 지향적이고 신뢰성이 있는 프로토콜입니다. 데이터 전송 시 연결을 설정하고, 오류 검출과 재전송을 통해 신뢰성을 보장합니다.
      UDP(User Datagram Protocol)는 비연결성이며 신뢰성이 낮은 프로토콜입니다. 데이터를 보낼 때 연결을 설정하지 않고, 오류 검출만 수행합니다.

68. TCP는 왜 3-way 핸드셰이크가 필요한가요?
    - 신뢰성 보장: 클라이언트가 서버에게 연결 요청을 보내는 단계와 서버가 클라이언트의 요청을 받았다고 응답하는 단계를 거침으로써, 양측 간에 신뢰성을 확보합니다. 만약 클라이언트가 서버에게 연결 요청을 보냈는데 이 요청이 손실되거나 지연되었다면, 클라이언트는 이에 대한 응답을 기다리기 때문에 잘못된 상태로 연결이 설정되지 않습니다.
      동기화: 3-way 핸드셰이크는 양측 간의 초기 숫자를 교환하고, 데이터 전송 순서를 결정하기 위해 사용되는 순차적인 메시지 교환입니다. 이로써 클라이언트와 서버는 데이터를 어떤 순서로 전송해야 할지 동기화됩니다.
      
69. OSI 모델의 일곱 개의 계층은 무엇인가요?
    - 물리(PHY) 계층: 비트 스트림을 전송하는 역할
      데이터 링크(Datalink) 계층: 네트워크 장치 간의 신뢰성 있는 데이터 전송을 담당
      네트워크(Network) 계층: 패킷을 목적지까지 전달하는 경로 선택과 라우팅을 처리
      전송(Transport) 계층: 송신자와 수신자 간의 신뢰성 있는 데이터 전송을 보장
      세션(Session) 계층: 세션 관리 및 동기화를 담당
      표현(Presentation) 계층: 데이터 표현과 암호화, 압축 등의 변환을 처리
      응용(Application) 계층: 사용자와 응용 프로그램 간의 통신을 담당

70. GET과 POST 요청의 차이점은 무엇인가요?
     - GET 요청은 데이터를 URL의 쿼리 문자열에 첨부하여 전송합니다. 주로 데이터를 요청하는 용도로 사용되며, 보안에 취약할 수 있습니다. 데이터 길이에 제한이 있습니다.
       POST 요청은 데이터를 요청의 본문에 담아서 전송합니다. 주로 데이터를 서버로 제출하는 용도로 사용되며, GET보다 보안성이 높습니다. 데이터 길이에 제한이 없습니다.

71 어떻게 도메인 간의 요청이 작동하나요?
    - 도메인 간 요청(Cross-Origin Request)은 웹 보안을 위한 중요한 개념 중 하나입니다. 웹 브라우저에서는 보안 상의 이유로 한 도메인(origin)에서 실행 중인 웹 페이지가 다른 도메인으로 요청을 보낼 때 일부 제한이 적용됩니다. 이것은 웹 사이트 간의 악의적인 데이터 유출을 방지하기 위한 것입니다.
      1. 동일 출처 정책은 웹 브라우저에서 실행되는 스크립트가 다른 출처(origin)로부터 데이터에 접근하는 것을 제한하는 보안 메커니즘입니다. 출처란 프로토콜, 호스트, 포트 번호를 의미합니다. 예를 들어, http://example.com 도메인에서 실행 중인 스크립트는 http://example.com 도메인의 리소스에는 자유롭게 접근할 수 있지만, 다른 출처인 http://otherdomain.com 도메인의 리소스에는 접근할 수 없습니다
      2. 만약 스크립트가 현재 도메인과 다른 출처에 있는 리소스에 접근하려면 크로스 도메인 요청을 사용해야 합니다. 이때는 동일 출처 정책을 우회하거나 극복하기 위해 추가적인 보안 검사가 필요합니다.

JSONP의 구현 원칙은 무엇인가요?
    - JSONP(JSON with Padding)는 웹 보안의 제약을 우회하고 도메인 간 요청을 가능하게 하는 방법 중 하나입니다. 주로 스크립트를 사용하여 다른 도메인으로부터 데이터를 가져오는 데 사용된다.

디자인 패턴에 대해 말해주세요.
    - 알아서 해라

알고 있는 디자인 패턴이 있으신가요?
    - 알아서 해라
    
추상 팩토리와 심플 팩토리의 차이가 무엇인가요?
    - 추상 팩토리: 서로 연관된 객체들을 무리지어 생성
      심플 팩토리: 단일 객체 생성        
         
      
72. 스프링을 사용하는 이점은 무엇인가
    - 대부분의 한국 사람들이 사용한다

73. AOP(Aspect-Oriented Programming)란 무엇인가요?     
    - AOP는 애플리케이션에서 공통적으로 발생하는 부가적인 기능들을 모듈화하여 관리하는 프로그래밍 패러다임입니다.
      AOP는 핵심 로직과 부가적인 기능을 분리하여 코드 중복을 줄이고, 관점에 따라 모듈을 재사용할 수 있습니다.
      스프링은 AOP를 지원하여 로깅, 트랜잭션 관리, 보안 등과 같은 부가 기능을 애플리케이션에 적용할 수 있습니다.
      
74. IoC(Inversion of Control)란 무엇인가요?
    - IoC는 객체의 생성과 의존성 관리를 프레임워크에 맡기는 개발 방법입니다.
      기존에는 개발자가 직접 객체를 생성하고 의존성을 설정해야 했지만, IoC 컨테이너를 통해 객체의 생명주기와 의존성 주입을 자동으로 관리할 수 있습니다.
      스프링은 IoC 컨테이너를 제공하여 객체의 생성과 의존성 주입을 관리합니다.

75. 스프링에서 가장 일반적으로 사용되는 주입 방법은 무엇인가요?
    - 스프링에서 가장 일반적으로 사용되는 주입 방법은 Setter 주입과 생성자 주입입니다.
      Setter 주입은 의존성을 설정하는 Setter 메서드를 통해 의존 객체를 주입하는 방식입니다.
      생성자 주입은 생성자를 통해 의존성을 주입하는 방식으로, 객체를 생성할 때 필요한 의존성을 외부에서 전달받습니다.
      둘 모두 XML 또는 Java Config를 사용하여 스프링 빈 설정에서 주입할 의존 객체를 지정할 수 있습니다.

76. 스프링의 주요 모듈은 무엇인가요?
    - 알아서 찾아보라
    
77. 스프링 빈은 스레드 안전한가요?
    -  스프링 빈은 기본적으로 싱글톤(Singleton) 스코프로 생성되며, 스레드 안전하지 않을 수 있습니다.
       싱글톤 스코프는 여러 스레드에서 동시에 해당 빈을 사용할 때 동기화 문제가 발생할 수 있습니다.
       스레드 안전한 빈을 사용하려면 프로토타입(Prototype) 스코프를 설정하거나 동기화를 적절히 처리해야 합니다.    
        
78. 스프링은 어떤 빈 스코프를 지원하나요 ?
    - 싱글톤: 기본 스코프로, 애플리케이션 전체에서 단일 인스턴스를 공유한다
      프로토타입: 요청할 때마다 새로운 인스턴스를 생성
      리퀘스트: http 요청마다 인스턴스를 생성하고, 요청 처리가 완료되면 인스턴스를 폐기한다
      세션: 각 사용자 세션마다 인스턴스를 생성하고 세션이 종료되면 폐기한다
      글로벌 세션: 포털 애플리케이션에서 사용되는 스코프로, 전역 세션마다 인스턴스를 생성하고, 세션이 종료되면 인스턴스를 폐기한다

79. 스프링 auto-assembles 빈을 위한 방법들을 말해주세요.
    - (1) Component Scan과 @Component 어노테이션:
          Spring에서 @Component 어노테이션을 사용하여 해당 클래스를 빈으로 등록할 수 있습니다. 또한 @Controller, @Service, @Repository 등의 어노테이션들도 @Component의 특수한 형태로 간주되며, 이들을 스캔하여 빈으로 등록하는 기능을 "Component Scan"이라고 합니다.
          @ComponentScan 어노테이션을 구성 클래스(Java Config)나 XML 설정 파일에서 사용하여 어느 패키지에서 빈을 찾을지 지정할 수 있습니다.                 
      (2) @Autowired 어노테이션:
          @Autowired 어노테이션은 필요한 의존성을 자동으로 주입하는데 사용됩니다. 이 어노테이션을 빈이 필요한 필드, 생성자, 메서드 매개변수에 적용하면 Spring은 해당 의존성을 찾아서 자동으로 주입해줍니다. 
      (3) @Qualifier 어노테이션:
          만약 같은 타입의 빈이 여러 개일 때, 어떤 빈을 주입할지를 정확하게 지정하기 위해 @Qualifier 어노테이션을 사용할 수 있습니다.
      (4) @Resource 어노테이션:
          @Resource 어노테이션은 Java EE에서 기본적으로 제공되는 어노테이션으로, Spring에서도 사용할 수 있습니다. 빈을 찾아서 주입할 때 빈의 이름을 기준으로 매칭됩니다.
      (5) Java Config 설정:
          Spring은 자바 설정을 통해 빈을 설정하는 Java Config 방식도 지원합니다. @Configuration 어노테이션을 사용하여 구성 클래스를 선언하고, @Bean 어노테이션을 사용하여 빈을 정의할 수 있습니다.

80. 스프링 트랜잭션을 구현하기 위한 다양한 방법을 말해주세요.
    - (1) 트랜잭션 동기화: 트랜잭션 동기화는 트랜잭션을 시작하기 위한 Connection 객체를 특별한 저장소에 보관해두고 필요할 때 꺼내쓸 수 있도록 하는 기술이다. 트랜잭션 동기화 저장소는 작업 쓰레드마다 Connection 객체를 독립적으로 관리하기 때문에, 멀티쓰레드 환경에서도 충돌이 발생할 여지가 없다. 그래서 다음과 같이 트랜잭션 동기화를 적용하게 된다.
      (2) 트랜잭션 추상화:   
      (3) aop를 이용한 트랜잭션 분리          
                 
81. 트랜잭션 고립이란 무엇인가
    - 스프링에서 트랜잭션 고립(Isolation)은 여러 개의 동시 트랜잭션이 동작할 때 어떤 트랜잭션이 다른 트랜잭션의 작업 내용을 볼 수 있는지와 관련된 개념입니다. 트랜잭션 고립은 데이터베이스에서 동시에 여러 트랜잭션이 발생할 때 데이터의 일관성과 격리 수준을 유지하기 위해 중요한 요소입니다.
    
82. 스프링 mvc의 런타임 flow는 무엇인가요?                     
    - 런타임 플로우는 클라이언트 요청이 컨트롤러를 통해 처리되고, 뷰를 생성하여 응답을 생성하는 과정을 나타낸다.
      클라이언트 요청 수신:
      먼저, 클라이언트(웹 브라우저 등)가 서버로 HTTP 요청을 보냅니다. 요청은 DispatcherServlet이라는 특별한 서블릿으로 전달됩니다.
      
      Handler Mapping:
      DispatcherServlet은 Handler Mapping을 사용하여 어떤 컨트롤러가 요청을 처리할지 결정합니다. Handler Mapping은 요청의 URL을 컨트롤러와 매핑시켜주는 역할을 합니다.
      
      Controller 호출:
      선택된 컨트롤러가 호출되고, 요청에 대한 처리를 수행합니다. 컨트롤러는 비즈니스 로직을 실행하거나 필요한 서비스를 호출합니다.
      
      모델 데이터 생성:
      컨트롤러는 클라이언트에게 보낼 데이터를 생성하고 모델에 저장합니다. 모델은 뷰로 전달될 데이터를 담는 객체입니다.
      
      View Resolver 및 View 선택:
      DispatcherServlet은 View Resolver를 사용하여 어떤 뷰를 사용할지 결정합니다. View Resolver는 뷰 이름을 실제 뷰 객체로 변환해주는 역할을 합니다.
      
      뷰 렌더링:
      선택된 뷰는 모델 데이터를 사용하여 실제 HTML, JSON, XML 등의 응답을 생성합니다. 이때 뷰 템플릿 엔진을 사용하여 동적으로 페이지를 생성할 수도 있습니다.
      
      응답 전송:
      생성된 응답은 클라이언트로 전송됩니다. 이 때, DispatcherServlet이 생성한 응답을 HTTP 응답으로 감싸서 전송합니다.
        
83. 스프링 mvc 컴포넌트는 무엇이 있나요?
    - DispatcherServlet:
      모든 클라이언트 요청을 받아들이고 적절한 핸들러(Controller)로 요청을 전달하는 중앙 허브 역할을 합니다.
      
      Controller:
      클라이언트 요청을 처리하고 비즈니스 로직을 수행하는 역할을 합니다. 컨트롤러는 @Controller 어노테이션을 사용하여 정의하며, 요청을 처리하고 모델 데이터를 생성한 뒤, 뷰로 전달합니다.
      
      Handler Mapping:
      클라이언트 요청을 어떤 컨트롤러가 처리할지를 결정하는 역할을 합니다. URL 패턴과 컨트롤러 사이의 매핑을 수행합니다.
      
      View Resolver:
      뷰의 이름을 실제 뷰 객체로 매핑하는 역할을 합니다. 뷰의 논리적인 이름을 물리적인 뷰 객체와 연결하여 뷰를 찾고 선택합니다.
      
      View:
      뷰는 모델 데이터를 사용하여 클라이언트에게 보여질 최종 응답을 생성합니다. 뷰는 일반적으로 HTML, JSON, XML 등의 형태로 응답을 생성할 수 있습니다.
      
      Model:
      컨트롤러에서 생성된 데이터를 저장하고 뷰로 전달하는 역할을 합니다. 모델은 뷰에 필요한 데이터를 가지고 있으며, 뷰에서 이를 활용하여 응답을 생성합니다.
      
      Handler Interceptor:
      요청과 응답 사이의 작업을 수행하며, 요청 전처리와 응답 후처리를 담당합니다. 보안 검증, 로깅 등을 처리할 수 있습니다.
      
      Locale Resolver:
      클라이언트의 언어 및 국가 설정을 기반으로 애플리케이션 내에서 언어 처리를 지원하는 역할을 합니다.
      
      Theme Resolver:
      사용자 인터페이스의 스타일 및 템플릿을 지원하기 위한 역할을 합니다. 테마마다 다른 뷰 리소스를 제공할 수 있습니다.
      
      Multipart Resolver:
      멀티파트 요청 데이터(파일 업로드 등)를 해석하고 처리하기 위한 역할을 합니다.
      
      이외에도 Spring MVC는 다양한 인터페이스와 클래스로 이루어져 있으며, 각각의 컴포넌트들이 웹 애플리케이션의 다양한 측면을 관리하고 구성하도록 도와줍니다.

84. @RequestMapping은 어떤 역할을 하나요?
    - @RequestMapping은 Spring MVC에서 컨트롤러 메서드에 부여되는 어노테이션으로, 해당 메서드가 어떤 요청 경로에 대해 호출될지를 지정하는 역할을 합니다. 즉, @RequestMapping은 클라이언트의 특정 URL 경로에 대해 어떤 메서드가 실행되어야 하는지를 매핑합니다.
    
85. @Autowired의 기능은 무엇인가요?
    - @Autowired는 Spring Framework에서 사용되는 어노테이션으로, 의존성 주입(Dependency Injection)을 자동으로 처리하는 역할을 합니다. Spring은 객체들 간의 의존성을 관리하고 필요한 객체를 주입하는데 사용됩니다. @Autowired 어노테이션을 필드, 생성자, 메서드 매개변수에 적용하여 의존성을 주입할 수 있습니다.      
           




         



                       
       
                                                  
    
         
        






















```