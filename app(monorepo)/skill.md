```
1. JPA
    - 객체와 db테이블을 mapping시켜 rdb테이블을 객체지향적으로 사용하게 해준다.
    사용 이유
        - 엔티티에 맞는 테이블 생성 및 db 생성 편리
        - 객체 지향 중심의 개발
        - 테스트 작성 용이
        - 기본적인 crud 자동화
        - 복잡한 쿼리는 Query DSL을 사용해 처리

2. Static
    - static 키워드를 사용한다는 것은 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 것을 의미한다.
    - 우리가 만든 class는 static 영역에 생성되고 new 연산을 통해 생성된 객체는 heap영역에 생성된다. 객체의 생성시 할당된 heap 영역의 메모리는
      가비지 컬렉터를 통해 수시로 관리를 받는다. 하지만 static 영역에 할당된 메모리는 모든 객체가 공유하는 메모리라는 장점을 지니지만, 가비지 컬렉터 관리 영역
      밖에 존재하므로, static을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재 하므로 주의를 해야 한다. 
    
    사용
        - 일반적으로 상수들의 값을 갖는 경우가 많으므로 public final을 붙여 사용한다. 
   
3. Otional
    - null이 올 수 있는 값을 감싸는 Wrapper 클래스이다. 참조하더라도 NPE가 발생하지 않도록 도와준다. Otional 클래스는 내부에서 static 변수로 empty 객체를 미리 생성해서 가지고 있다.
      이러한 이유로 빈 객체를 여러 번 생성해줘야 하는 겨웅에도 1개의 empty 객체를 공유함으로써 메모리를 절약하고 있따.
    
    사용
        - Optional.of() - 값이 Null이 아닌 경우
        - Optional.ofNullbale() - 값이 Null일수도, 아닐수도 있는 경우(이후에 orElse 또는 orElseGet 메소드를 이용해서 값이 없는 경우라도 안전하게 값을 가져올 수 있다.)

4. Enum
    - 일반적으로 상수를 정의할 때 public static final으로 상수를 정의한다. 하지만 이런식의 상수 정의는 다양한 문제를 발생시켰다. 따라서 열거형 클래스 enum을 도입하게 됨
        발생한 문제
            - 상수 값을 변경할 때
            - 컴파일 타임에 값을 할당받는데, 이러한 경우 사용자의 입력에 따라 다른 값을 이용할 수 없다.
            - 하드코딩되어있어 의존성이 높고 수정이 어렵다
            - 불필요한 메모리 사용 초래        
    
    사용이유
        - 코드가 단순해지며 가독성이 좋다.
        - 인스턴스 생성과 상속을 방지하여 컴파일 시에 상수값의 타입 안정성이 보장된다.
        - enum 키워드를  통해 구현의 의도가 열거임을 분명히 알 수 있다. 
        - enum과 functinal interface를 이용하여 확장성이라는 이점을 가질 수 있다. 구현된 기능중 하나인 좋아요(like) 기능에서 클라이언트에 들어오는 json 값을 
          enum에 열거하여, 그 값에 맞는 type을 찾아(게시물,댓글,공지 등...) 좋아요를 증가시킨다.

5. Lombok
    - 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리이다. 롬복을 사용하여 코드의 가독성을 증가싴킬 수 있다.(VO 클래스에 수많은 get, set을 줄일 수 있다.)
    
    사용이유
        - 어노테이션 기반의 코드 자동 생성을 통한 생산성 향상
        - 반복되는 코드 다이어트를 통한 가독성 및 유지보수 향상
        - Getter, Setter 외에 빌더 패턴이나 로그 생성 등 다양한 방면으로 활용 가능
        - @Setter 어노테이션은 최대한 사용을 지양했다. 
    
    사용
        - @AllArgsConstructor: 모든 변수를 사용하는 생성자를 자동완성 시켜주는 어노테이션이다.
        - @NoArgsConstructor: 어떠한 변수도 사용하지 않는 기본 생성자를 자동완성 시켜주는 어노테이션이다.
        - @RequiredArgsConstructor: 특정 변수만을 활용하는 생성자를 자동완성 시켜주는 어노테이션이다. 생성자의 인자로 추가할 변수에 @NonNull 어노테이션을 붙여서 해당 변수를 생성자의 인자로 추가할 수 있다. 아니면 해당 변수를 final로 선언해도 의존성을 주입받을 수 있다.
        - @ToString: 클래스의 변수들을 기반으로 ToString 메소드를 자동으로 완성시켜 준다. 출력을 원하지 않는 변수에 @ToString.Exclude 어노테이션을 붙여주면 출력을 제외할 수 있다. 또한 상위 클래스에 대해도 toString을 적용시키고자 한다면 상위 클래스에 @ToString(callSuper = true) 를 적용시키면 된다.
        - @Data: @ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor를 자동완성 시켜준다. 실무에서는 너무 무겁고 객체의 안정성을 지키기 때문에 @Data의 활용을 지양한다.
        - @Builder: 해당 클래스의 객체의 생성에 Builder패턴을 적용시켜준다.
        - @Delegate: 한 객체의 메소드를 다른 객체로 위임시켜 준다.
         
```